import React__default, { createContext, useContext, useEffect, useRef, useLayoutEffect, useMemo, useImperativeHandle, useState, useReducer, createElement as createElement$1 } from 'react';
import invariant from 'fbjs/lib/invariant';
import { Physics, GameObjects, Game as Game$1, Scene as Scene$2 } from 'phaser';
import Reconciler from 'react-reconciler';
import performanceNow from 'performance-now';
import uuid from 'uuid/v4';

var SceneContext =
/*#__PURE__*/
createContext(null);

function useScene() {
  return useContext(SceneContext);
}

var GameContext =
/*#__PURE__*/
createContext(null);

function useGame() {
  return useContext(GameContext);
}

function useGameEvent(event, onEvent) {
  var game = useGame();
  useEffect(function () {
    game.events.on(event, onEvent);
    return function () {
      game.events.off(event, onEvent);
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [onEvent]);
}

/**
 * Runs the callback once every "step" event
 *
 * note: this is shorthand for useGameEvent("step", callback)
 */

function useGameLoop(onLoop) {
  var game = useGame();
  useEffect(function () {
    var callback = function callback(time, delta) {
      onLoop({
        delta: delta,
        time: time
      });
    };

    game.events.on('step', callback);
    return function () {
      game.events.off('step', callback);
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [onLoop]);
}

function useInputEvent(event, callback) {
  var scene = useScene();
  useEffect(function () {
    !!!scene ? process.env.NODE_ENV !== "production" ? invariant(false, '`useInputEvent` could not find the scene. Make sure it is used in a component that is a child of <Scene />') : invariant(false) : void 0;
    scene.input.on(event, callback);
    return function () {
      scene.input.off(event, callback);
    };
  }, [scene, event, callback]);
}

function useKeyboardEvent(event, callback) {
  var scene = useScene();
  useEffect(function () {
    !!!scene ? process.env.NODE_ENV !== "production" ? invariant(false, '`useKeyboardEvent` could not find the scene. Make sure it is used in a component that is a child of <Scene />') : invariant(false) : void 0;
    scene.input.keyboard.on(event, callback);
    return function () {
      scene.input.keyboard.off(event, callback);
    };
  }, [scene, event, callback]);
}

function useGamepadEvent(event, callback) {
  var scene = useScene();
  useEffect(function () {
    !!!scene ? process.env.NODE_ENV !== "production" ? invariant(false, '`useGamepadEvent` could not find the scene. Make sure it is used in a component that is a child of <Scene />') : invariant(false) : void 0;
    scene.input.gamepad.on(event, callback);
    return function () {
      scene.input.gamepad.off(event, callback);
    };
  }, [scene, event, callback]);
}

function findGameObjectsByName(scene, name) {
  return scene.children.list.filter(function (child) {
    return child.name === name;
  });
}

/**
 * Creates a collider between objects or arrays of objects. If provided values are strings, it will
 * search for all objects by that name in the scene.
 */

function useArcadeCollider(obj1, obj2, args) {
  var onCollide = args.onCollide,
      onProcess = args.onProcess,
      overlapOnly = args.overlapOnly;
  var scene = useScene();
  var collider = useRef(null);
  useLayoutEffect(function () {
    collider.current = scene.physics.add.collider(createObjectsArray(scene, obj1), createObjectsArray(scene, obj2), onCollide, onProcess);
    collider.current.overlapOnly = overlapOnly;
    return function () {
      collider.current.destroy();
    };
  }, []); // it is much more performant to update the collider via mutations
  // rather than destroy() and recreate in the above useLayoutEffect

  useLayoutEffect(function () {
    if (collider.current) {
      collider.current.object1 = createObjectsArray(scene, obj1);
      collider.current.object2 = createObjectsArray(scene, obj2);
    }
  }, [obj1, obj2]);
  useLayoutEffect(function () {
    if (collider.current) {
      collider.current.collideCallback = onCollide;
      collider.current.processCallback = onProcess;
      collider.current.overlapOnly = overlapOnly;
    }
  }, [onCollide, onProcess, overlapOnly]);
}

function createObjectsArray(scene, objects) {
  return toArray(objects).reduce(function (total, object) {
    if (typeof object === 'string') {
      return [].concat(total, findGameObjectsByName(scene, object));
    }

    return [].concat(total, [object]);
  }, []);
}

function toArray(obj) {
  return Array.isArray(obj) ? obj : [obj];
}

var SpawnerContext =
/*#__PURE__*/
createContext(null);

function useSpawner() {
  return useContext(SpawnerContext);
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

/**
 * Reserved props
 */
var PROPS_RESERVED = {
  children: true,
  parent: true,
  object: true,
  physics: true,
  physicsType: true,
  instance: true,
  scene: true
};
/**
 * Removes any props that have reserved names
 * @param props
 */

function sanitizeProps(props) {
  return Object.keys(props).reduce(function (filteredProps, key) {
    if (Object.keys(PROPS_RESERVED).indexOf(key) === -1) {
      var _extends2;

      return _extends({}, filteredProps, (_extends2 = {}, _extends2[key] = props[key], _extends2));
    }

    return _extends({}, filteredProps);
  }, {});
}

function applyProps(instance, oldProps, newProps) {
  Object.keys(sanitizeProps(newProps)).forEach(function (key) {
    var _instance$body;

    if (typeof newProps[key] !== 'undefined' && oldProps[key] !== newProps[key]) {
      var newValue = newProps[key];

      switch (key) {
        case 'data':
          Object.keys(newProps.data).forEach(function (dataKey) {
            instance.setData(dataKey, newProps.data[dataKey]);
          });
          break;

        /** Point values **/

        case 'acceleration':
        case 'bounce':
        case 'drag':
        case 'friction':
        case 'gravity':
        case 'velocity':
        case 'maxVelocity':
          {
            var oldPoint = convertToPoint(oldProps[key]);
            var newPoint = convertToPoint(newProps[key]);

            if (!pointsAreEqual(oldPoint, newPoint)) {
              setProp(instance, key, newPoint.x, newPoint.y);
            }

            break;
          }

        /** Animation **/

        case 'accumulator':
        case 'delay':
        case 'duration':
        case 'forward':
        case 'frameRate':
        case 'isPlaying':
        case 'msPerFrame':
        case 'skipMissedFrames':
        case 'progress':
        case 'stopOnFrame':
        case 'stopAfterDelay':
        case 'repeat':
        case 'repeatDelay':
        case 'timeScale':
        case 'yoyo':
          setProp(instance.anims, key, newValue);
          break;

        /** Physics **/

        case 'debug':
          if (oldProps.debugShowBody !== newProps.debugShowBody || oldProps.debugShowVelocity !== newProps.debugShowVelocity || oldProps.debugBodyColor !== newProps.debugBodyColor) {
            instance.setDebug(newProps.debugShowBody, newProps.debugShowVelocity, newProps.debugBodyColor);
          }

          break;

        case 'disableBody':
        case 'hideBody':
          if (oldProps.disableBody !== newProps.disableBody || oldProps.hideBody !== newProps.hideBody) {
            instance.disableBody(newProps.disableBody, newProps.hideBody);
          }

          break;

        case 'circle':
          if (newProps.circle) {
            if (!oldProps.circle || oldProps.circle.radius !== newProps.circle.radius || oldProps.circle.offsetX !== newProps.circle.offsetX || oldProps.circle.offsetY !== newProps.circle.offsetY) {
              instance.setCircle(newProps.circle.radius, newProps.circle.offsetX, newProps.circle.offsetY);
            }
          }

          break;

        case 'offset':
          if (!oldProps.offset || oldProps.offset.x !== newProps.offset.x || oldProps.offset.y !== newProps.offset.y) {
            instance.setOffset(newProps.offset.x, newProps.offset.y);
          }

          break;

        case 'onWorldBounds':
          setProp(instance.body, key, newValue);
          break;

        case 'size':
          if (newProps.size) {
            if (!oldProps.size || oldProps.size.width !== newProps.size.width || oldProps.size.height !== newProps.size.height || oldProps.size.center !== newProps.size.center) {
              instance.setSize(newProps.size.width, newProps.size.height, newProps.size.center);
            }
          }

          break;

        case 'allowGravity':
        case 'allowDrag':
        case 'allowAcceleration':
          setProp(instance.body, key, newValue);
          break;

        case 'scale':
          if (typeof newValue === 'number') {
            instance.setScale(newValue);
          } else {
            instance.setScale(newValue.x, newValue.y, newValue.point ? [newValue.point.x, newValue.point.y] : undefined);
          } // if static, refresh body. there are probably other keys that need this


          if (((_instance$body = instance.body) === null || _instance$body === void 0 ? void 0 : _instance$body.physicsType) === 1) {
            instance.body.updateFromGameObject();
          }

          break;

        default:
          setProp(instance, key, newProps[key]);
      }
    }
  });
}

function setProp(instance, key) {
  // get method name for property. ex: 'setStyle' for 'style'
  var methodName = "set" + (key.slice(0, 1).toUpperCase() + key.slice(1));

  for (var _len = arguments.length, value = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    value[_key - 2] = arguments[_key];
  }

  if (instance[methodName]) {
    instance[methodName].apply(instance, value);
  } else {
    if (typeof instance[key] === 'function') {
      instance[key].apply(instance, value);
    } else {
      // ...value will always be an array, so we'll get the [0] value
      instance[key] = value[0];
    }
  }
}

function convertToPoint(num) {
  if (typeof num === 'number') {
    return {
      x: num,
      y: num
    };
  }

  if (!num) {
    return {
      x: 0,
      y: 0
    };
  }

  return num;
}

function pointsAreEqual(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}

var GameObject = {
  create: function create(_ref) {
    var instance = _ref.instance,
        scene = _ref.scene,
        physics = _ref.physics,
        physicsType = _ref.physicsType;
    // @ts-ignore - we need to set the scene key so hostconfig knows which scene to add this instance to
    instance.__reactPhaser = {
      sceneKey: scene.scene.key
    }; // if this is a physics object we need to add the body before applyProps

    if (physics === 'arcade' && scene) {
      scene.physics.world.enable(instance, physicsType === 'static' ? Phaser.Physics.Arcade.STATIC_BODY : Phaser.Physics.Arcade.DYNAMIC_BODY);
    }

    return instance;
  },
  applyProps: function applyProps$1(instance, oldProps, newProps) {
    applyProps(instance, oldProps, newProps);
  }
};

var TYPES = {
  GameObject: 'GameObject'
};
var ELEMENTS = {
  GameObject: GameObject
};
/**
 * Create an element based on tag type
 * Similar to react-dom's `React.createElement()`
 *
 * @param {string} type Element type
 * @param {Object} props Component props
 * @param {Object} root Root instance
 */

function createElement(type, props, root) {
  if (props === void 0) {
    props = {};
  }

  var _ELEMENTS$type = ELEMENTS[type],
      create = _ELEMENTS$type.create,
      _ELEMENTS$type$applyP = _ELEMENTS$type.applyProps,
      applyProps$1 = _ELEMENTS$type$applyP === void 0 ? applyProps : _ELEMENTS$type$applyP;
  var instance = create(props, root);
  instance.applyProps = applyProps$1.bind(instance);
  applyProps$1(instance, {}, props);
  return instance;
}

var GroupContext =
/*#__PURE__*/
React__default.createContext(null);

function Group(_ref, ref) {
  var children = _ref.children,
      props = _objectWithoutPropertiesLoose(_ref, ["children"]);

  var scene = useScene();
  var group = useMemo(function () {
    return scene.add.group([]);
  }, []);
  useLayoutEffect(function () {
    return function () {
      group.destroy();
    };
  }, []);
  useImperativeHandle(ref, function () {
    return group;
  });
  useLayoutEffect(function () {
    group.active = props.active;
    group.defaultFrame = props.defaultFrame;
    group.defaultKey = props.defaultKey;
    group.isParent = props.isParent;
    group.name = props.name;
  }, [props]);
  return React__default.createElement(GroupContext.Provider, {
    value: group
  }, children);
}

var Group$1 = /*#__PURE__*/
React__default.forwardRef(Group);
function useGroup() {
  return useContext(GroupContext);
}

var GameObjectElement = TYPES.GameObject;
var GameObjectContext =
/*#__PURE__*/
React__default.createContext(null);
function GameObject$1(props) {
  var scene = useScene();
  var group = useGroup();
  useLayoutEffect(function () {
    if (group) {
      group.add(props.instance);
      return function () {
        group.remove(props.instance);
      };
    }
  }, [group]);
  return React__default.createElement(GameObjectContext.Provider, {
    value: props.instance
  }, React__default.createElement(GameObjectElement, Object.assign({
    scene: scene
  }, props)), props.children);
}

function useGameObject() {
  return useContext(GameObjectContext);
}

/**
 * Creates a collider between the parent GameObject component and the "with" prop. The
 * "with" prop can either be a GameObject, a ref to a GameObject, or a string matching
 * the name of a GameObject (in Phaser).
 *
 * ```
 *  <ArcadeImage {...props}>
 *    <ArcadeCollider with="coin">
 *  </ArcadeImage>
 * ```
 *
 * You can also use it with a custom GameObject component
 *
 * ```
 *  <GameObject instance={instance}>
 *    <ArcadeCollider with="coin">
 *  </GameObject>
 * ```
 *
 */

function ArcadeCollider(props) {
  var onCollide = props.onCollide,
      onProcess = props.onProcess,
      overlapOnly = props.overlapOnly;
  var gameObject = useGameObject();

  if (!gameObject) {
    throw Error('ArcadeCollider must be used within a GameObject component');
  }

  useArcadeCollider(gameObject, props["with"], {
    overlapOnly: overlapOnly,
    onCollide: onCollide,
    onProcess: onProcess
  });
  return null;
}

function ArcadeImage(props, ref) {
  var scene = useScene();
  var instance = useMemo(function () {
    return props.instance || new Physics.Arcade.Image(scene, props.x, props.y, props.texture, props.frame);
  }, []);
  useImperativeHandle(ref, function () {
    return instance;
  });
  return React__default.createElement(GameObject$1, Object.assign({
    instance: instance,
    physics: "arcade"
  }, props));
}

var ArcadeImage$1 = /*#__PURE__*/
React__default.forwardRef(ArcadeImage);

function Sprite(_ref, ref) {
  var animations = _ref.animations,
      animation = _ref.animation,
      props = _objectWithoutPropertiesLoose(_ref, ["animations", "animation"]);

  var scene = useScene();
  var instance = useMemo(function () {
    return props.instance || new GameObjects.Sprite(scene, props.x, props.y, props.texture, props.frame);
  }, []);
  useImperativeHandle(ref, function () {
    return instance;
  });
  useLayoutEffect(function () {
    if (animations) {
      animations.forEach(function (animation) {
        scene.anims.create(animation);
      });
    }

    return function () {
      if (animations) {
        animations.forEach(function (animation) {
          scene.anims.remove(animation.key);
        });
      }
    };
  }, [animations]);
  useLayoutEffect(function () {
    if (animation) {
      instance.play(animation, true);
    }
  }, [animation]);
  return React__default.createElement(GameObject$1, Object.assign({
    instance: instance
  }, props));
}

var Sprite$1 = /*#__PURE__*/
React__default.forwardRef(Sprite);

function ArcadeSprite(props, ref) {
  var scene = useScene();
  var instance = useMemo(function () {
    return props.instance || new Physics.Arcade.Sprite(scene, props.x, props.y, props.texture, props.frame);
  }, []);
  useImperativeHandle(ref, function () {
    return instance;
  }); // reuse the Sprite component because it does some Sprite prop things
  // but we'll need to disguise the props as any. This is smelly, but does
  // share the common Sprite logic

  return React__default.createElement(Sprite$1, Object.assign({
    instance: instance,
    physics: "arcade"
  }, props));
}

var ArcadeSprite$1 = /*#__PURE__*/
React__default.forwardRef(ArcadeSprite);

var name = "react-phaser-fiber";
var version = "0.2.4";
var license = "ISC";
var homepage = "https://github.com/mattjennings/react-phaser-fiber";
var repository = {
	type: "git",
	url: "https://github.com/mattjennings/react-phaser-fiber"
};
var description = "Create Phaser 3 games with React";
var main = "dist/index.js";
var keywords = [
	"phaser",
	"react"
];
var module = "dist/react-phaser-fiber.esm.js";
var typings = "dist/index.d.ts";
var files = [
	"dist"
];
var scripts = {
	start: "tsdx watch",
	build: "tsdx build",
	test: "tsdx test --env=jsdom",
	prepare: "cp ../../README.md README.md && yarn build",
	publish: "npm publish"
};
var peerDependencies = {
	react: ">=16"
};
var devDependencies = {
	"@testing-library/react": "^9.4.0",
	"@types/jest": "^24.0.17",
	"@types/react": "^16.9.1",
	"@types/react-dom": "^16.8.5",
	"@types/react-reconciler": "^0.18.0",
	"@types/uuid": "^3.4.5",
	canvas: "^2.6.1",
	datauri: "^2.0.0",
	jest: "^25.1.0",
	"jest-canvas-mock": "^2.2.0",
	"jest-environment-jsdom": "^25.1.0",
	jsdom: "^16.1.0",
	nock: "^12.0.0",
	react: "^16.9.0",
	"react-dom": "^16.9.0",
	tsdx: "^0.12.3",
	tslib: "^1.10.0",
	typescript: "^3.7.5",
	waait: "^1.0.5"
};
var dependencies = {
	fbjs: "^1.0.0",
	"performance-now": "^2.1.0",
	phaser: "^3.19.0",
	"react-reconciler": "^0.21.0",
	uuid: "^3.3.3"
};
var pkg = {
	name: name,
	version: version,
	license: license,
	homepage: homepage,
	repository: repository,
	description: description,
	main: main,
	keywords: keywords,
	module: module,
	typings: typings,
	files: files,
	scripts: scripts,
	peerDependencies: peerDependencies,
	devDependencies: devDependencies,
	dependencies: dependencies
};

/**
 * -------------------------------------------
 * Host Config file.
 *
 * See:
 *   https://github.com/facebook/react/tree/master/packages/react-reconciler
 *   https://github.com/facebook/react/blob/master/packages/react-reconciler/src/forks/ReactFiberHostConfig.custom.js
 * -------------------------------------------
 */

function appendChild(parent, child) {
  // __reactPhaser.sceneKey comes from GameObject's element creator
  if (parent instanceof Phaser.Game && child.__reactPhaser.sceneKey) {
    var scene = parent.scene.getScene(child.__reactPhaser.sceneKey);

    if (!scene.children.exists(child)) {
      scene.add.existing(child);
    }
  }

  if (parent instanceof Phaser.GameObjects.GameObject) ;
}

function removeChild(parent, child) {
  if (child.destroy) {
    child.destroy();
  }
}

function insertBefore(parent, child, beforeChild) {
  !(child !== beforeChild) ? process.env.NODE_ENV !== "production" ? invariant(false, 'PhaserFiber cannot insert node before itself') : invariant(false) : void 0;

  if (parent instanceof Phaser.Game) {
    var scene = parent.scene.getScene(child.__reactPhaser.sceneKey);
    var childExists = scene.children.exists(child);
    var index = scene.children.getIndex(beforeChild);
    childExists ? scene.children.moveTo(child, index) : scene.children.addAt(child, index);
  }
} // get diff between 2 objects
// https://github.com/facebook/react/blob/97e2911/packages/react-dom/src/client/ReactDOMFiberComponent.js#L546


function diffProperties(phaserElement, type, lastProps, nextProps, rootContainerElement) {
  var updatePayload = null;

  for (var propKey in lastProps) {
    if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
      continue;
    }

    if (propKey === 'children') ; else {
      // For all other deleted properties we add it to the queue. We use
      // the whitelist in the commit phase instead.
      if (!updatePayload) {
        updatePayload = [];
      }

      updatePayload.push(propKey, null);
    }
  }

  for (var _propKey in nextProps) {
    var nextProp = nextProps[_propKey];
    var lastProp = lastProps != null ? lastProps[_propKey] : undefined;

    if (!nextProps.hasOwnProperty(_propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
      continue;
    }

    if (_propKey === 'children') ; else {
      // For any other property we always add it to the queue and then we
      // filter it out using the whitelist during the commit.
      if (!updatePayload) {
        updatePayload = [];
      }

      updatePayload.push(_propKey, nextProp);
    }
  }

  return updatePayload;
}

var hostconfig = {
  getRootHostContext: function getRootHostContext(rootContainerInstance) {
    return rootContainerInstance;
  },
  getChildHostContext: function getChildHostContext() {
    return {};
  },
  getChildHostContextForEventComponent: function getChildHostContextForEventComponent(parentHostContext) {
    return parentHostContext;
  },
  getPublicInstance: function getPublicInstance(instance) {
    return instance;
  },
  prepareForCommit: function prepareForCommit() {// noop
  },
  resetAfterCommit: function resetAfterCommit() {// noop
  },
  createInstance: createElement,
  hideInstance: function hideInstance(instance) {
    if (instance.setActive) {
      instance.setActive(false);
    }
  },
  unhideInstance: function unhideInstance(instance, props) {
    var active = props !== undefined && props !== null && props.hasOwnProperty('active') ? props.active : true;
    instance.setActive(active);
  },
  appendInitialChild: appendChild,
  finalizeInitialChildren: function finalizeInitialChildren(phaserElement, type, props) {
    return false;
  },
  prepareUpdate: function prepareUpdate(phaserElement, type, oldProps, newProps, rootContainerInstance, hostContext) {
    return diffProperties(phaserElement, type, oldProps, newProps);
  },
  shouldSetTextContent: function shouldSetTextContent(type, props) {
    return false;
  },
  shouldDeprioritizeSubtree: function shouldDeprioritizeSubtree(type, props) {
    var isActive = typeof props.active === 'undefined' || props.active === true;
    return !isActive;
  },
  createTextInstance: function createTextInstance(text, rootContainerInstance, internalInstanceHandler) {
     process.env.NODE_ENV !== "production" ? invariant(false, 'react-phaser does not support text instances. Use `<Text /> component` instead.') : invariant(false) ;
  },
  mountEventComponent: function mountEventComponent() {// noop
  },
  updateEventComponent: function updateEventComponent() {// noop
  },
  handleEventTarget: function handleEventTarget() {// noop
  },
  scheduleTimeout: setTimeout,
  cancelTimeout: clearTimeout,
  noTimeout: -1,
  warnsIfNotActing: false,
  now: performanceNow,
  isPrimaryRenderer: false,
  supportsMutation: true,
  supportsPersistence: false,
  supportsHydration: false,

  /**
   * -------------------------------------------
   * Mutation
   * -------------------------------------------
   */
  appendChild: appendChild,
  appendChildToContainer: appendChild,
  removeChild: removeChild,
  removeChildFromContainer: removeChild,
  insertBefore: insertBefore,
  insertInContainerBefore: insertBefore,
  commitUpdate: function commitUpdate(instance, updatePayload, type, oldProps, newProps) {
    var applyProps$1 = instance && instance.applyProps;

    if (typeof applyProps$1 !== 'function') {
      applyProps$1 = applyProps;
    }

    applyProps$1(instance, oldProps, newProps);
  },
  commitMount: function commitMount(instance, updatePayload, type, oldProps, newProps) {// noop
  },
  commitTextUpdate: function commitTextUpdate(textInstance, oldText, newText) {// noop
  },
  resetTextContent: function resetTextContent(phaserElement) {// noop
  }
};

var PhaserFiber =
/*#__PURE__*/
Reconciler(hostconfig);
var VERSION = pkg.version;
var PACKAGE_NAME = pkg.name;

var Game =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(Game, _React$Component);

  function Game() {
    var _this;

    _this = _React$Component.apply(this, arguments) || this;
    _this.state = {
      booting: true
    };
    return _this;
  }

  var _proto = Game.prototype;

  _proto.componentDidMount = function componentDidMount() {
    var _this2 = this;

    var _this$props = this.props,
        config = _objectWithoutPropertiesLoose(_this$props, ["children", "canvas"]);

    this.game = new Game$1(_extends({}, config));
    this.game.events.on('ready', function () {
      _this2.setState({
        booting: false
      });
    });
    this.mountNode = PhaserFiber.createContainer(this.game, false, false);
    injectDevtools();

    if (process.env.NODE_ENV === 'development') {
      // @ts-ignore
      window.game = this.game;
    }

    PhaserFiber.updateContainer(this.getChildren(), this.mountNode, this, null);
  };

  _proto.componentDidUpdate = function componentDidUpdate() {
    // flush fiber
    PhaserFiber.updateContainer(this.getChildren(), this.mountNode, this, null);
  };

  _proto.getChildren = function getChildren() {
    var children = this.state.booting ? null : this.props.children;
    return React__default.createElement(GameContext.Provider, {
      value: this.game
    }, children);
  };

  _proto.componentDidCatch = function componentDidCatch(error, errorInfo) {
    console.error("Error occurred in `Game`.");
    console.error(error);
    console.error(errorInfo);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    PhaserFiber.updateContainer(null, this.mountNode, this, null);
    this.game.destroy(true);
  };

  _proto.render = function render() {
    return null;
  };

  return Game;
}(React__default.Component);

Game.displayName = 'Game';
/**
 * Inject into React Devtools
 */

function injectDevtools() {
  PhaserFiber.injectIntoDevTools({
    bundleType: process.env.NODE_ENV !== 'production' ? 1 : 0,
    version: VERSION,
    rendererPackageName: PACKAGE_NAME,
    findFiberByHostInstance: PhaserFiber.findHostInstance
  });
}

function Image(props, ref) {
  var scene = useScene();
  var instance = useMemo(function () {
    return props.instance || new GameObjects.Image(scene, props.x, props.y, props.texture, props.frame);
  }, []);
  useImperativeHandle(ref, function () {
    return instance;
  });
  return React__default.createElement(GameObject$1, Object.assign({
    instance: instance
  }, props));
}

var Image$1 = /*#__PURE__*/
React__default.forwardRef(Image);

function Scene(_ref, ref) {
  var sceneKey = _ref.sceneKey,
      children = _ref.children,
      renderLoading = _ref.renderLoading,
      onPreload = _ref.onPreload,
      onCreate = _ref.onCreate,
      onInit = _ref.onInit,
      options = _objectWithoutPropertiesLoose(_ref, ["sceneKey", "children", "renderLoading", "onPreload", "onCreate", "onInit"]);

  var game = useGame();

  var _useState = useState(!!onPreload),
      loading = _useState[0],
      setLoading = _useState[1];

  var _useState2 = useState(0),
      loadProgress = _useState2[0],
      setLoadProgress = _useState2[1];

  var scene = useMemo(function () {
    var instance = new Scene$2(_extends({}, options, {
      key: sceneKey
    })); // @ts-ignore

    instance.preload = onPreload ? function () {
      onPreload(instance);
      instance.load.once('complete', function () {
        setLoading(false);
        setLoadProgress(0);
      });
      instance.load.start();
    } : null; // @ts-ignore

    instance.create = onCreate ? function () {
      return onCreate(instance);
    } : null; // @ts-ignore

    instance.init = onInit ? function () {
      return onInit(instance);
    } : null;
    game.scene.add(sceneKey, instance, true);
    return instance;
  }, []);
  useImperativeHandle(ref, function () {
    return scene;
  });
  useLayoutEffect(function () {
    var listeners = []; // can we use suspense instead somehow?

    listeners.push(scene.load.once('start', function () {
      setLoading(!!onPreload);
    }), scene.load.on('progress', function (progress) {
      setLoadProgress(progress);
    }));
    return function () {
      game.scene.remove(sceneKey);
      listeners.forEach(function (listener) {
        listener.eventNames().forEach(function (event) {
          return listener.off(event);
        });
      });
    };
  }, []);
  return React__default.createElement(SceneContext.Provider, {
    value: scene
  }, loading && renderLoading ? renderLoading(loadProgress) : children);
}

var Scene$1 = /*#__PURE__*/
React__default.forwardRef(Scene);

function Spawner(_ref) {
  var children = _ref.children;

  var _useReducer = useReducer(reducer, {
    children: []
  }),
      state = _useReducer[0],
      dispatch = _useReducer[1];

  var handleDestroy = function handleDestroy(key) {
    dispatch({
      type: 'DESTROY_CHILD',
      payload: key
    });
  };

  var value = useMemo(function () {
    return {
      spawn: function spawn(component, props) {
        var key = uuid();
        dispatch({
          type: 'SPAWN',
          payload: {
            component: component,
            props: props,
            key: key
          }
        });
        return key;
      }
    };
  }, [state]);
  return React__default.createElement(SpawnerContext.Provider, {
    value: value
  }, state.children.map(function (child) {
    return React__default.createElement(child.component, Object.assign({
      key: child.key
    }, child.props, {
      onDestroy: function onDestroy() {
        if (child.props.onDestroy) {
          child.props.onDestroy();
        }

        handleDestroy(child.key);
      }
    }));
  }), children);
}

function reducer(state, action) {
  switch (action.type) {
    case 'SPAWN':
      return _extends({}, state, {
        children: [].concat(state.children, [action.payload])
      });

    case 'DESTROY_CHILD':
      return _extends({}, state, {
        children: state.children.filter(function (child) {
          return child.key !== action.payload;
        })
      });
  }

  return state;
}

var withSpawner = function withSpawner(Component) {
  function WithSpawner(props) {
    return createElement$1(SpawnerContext.Consumer, null, function (spawner) {
      return createElement$1(Component, Object.assign({}, props, {
        spawner: spawner
      }));
    });
  }

  WithSpawner.displayName = "WithSpawner(" + Component.displayName + ")";
  return WithSpawner;
};

function Text(props, ref) {
  var scene = useScene();
  var instance = useMemo(function () {
    return props.instance || new GameObjects.Text(scene, props.x, props.y, props.text, props.style);
  }, []);
  useImperativeHandle(ref, function () {
    return instance;
  });
  return React__default.createElement(GameObject$1, Object.assign({
    instance: instance
  }, props));
}

var Text$1 = /*#__PURE__*/
React__default.forwardRef(Text);

export { ArcadeCollider, ArcadeImage$1 as ArcadeImage, ArcadeSprite$1 as ArcadeSprite, Game, GameObject$1 as GameObject, GameObjectContext, Group$1 as Group, Image$1 as Image, Scene$1 as Scene, Spawner, SpawnerContext, Sprite$1 as Sprite, Text$1 as Text, findGameObjectsByName, useArcadeCollider, useGame, useGameEvent, useGameLoop, useGameObject, useGamepadEvent, useGroup, useInputEvent, useKeyboardEvent, useScene, useSpawner, withSpawner };
//# sourceMappingURL=react-phaser-fiber.esm.js.map
